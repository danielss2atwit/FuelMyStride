import Constants from 'expo-constants';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { getLogs, getWellnessLogs } from './utils/storage';
import { calculateTrainingLoad, getPortionRangesFromPlate } from './utils/FuelUtils';


export const clearInsights = async () => {
  try {
    await AsyncStorage.removeItem('NUTRITION_INSIGHTS');
    console.log('Insights cleared');
  } catch (error) {
    console.error('Error clearing insights:', error);
  }
};

export const generateNutritionInsights = async () => {
  try {
    const foodLogs = await getLogs('FOOD_LOGS') || [];
    const workoutLogs = await getLogs('WORKOUT_LOGS') || [];
    const wellnessLogs = await getWellnessLogs();
    

    const fourteenDaysAgo = new Date();
    fourteenDaysAgo.setDate(fourteenDaysAgo.getDate() - 14);

    const recentFoodLogs = foodLogs.filter(log =>
      new Date(log.timestamp) >= sevenDaysAgo
    ).slice(-20);

    const recentWorkoutLogs = workoutLogs.filter(log =>
      new Date(log.timestamp) >= sevenDaysAgo
    ).slice(-10);

    const recentWellnessLogs = wellnessLogs.filter(log =>
  new Date(log.date) >= fourteenDaysAgo
);

    console.log("Recent Food Logs:", recentFoodLogs);
    console.log("Recent Workout Logs:", recentWorkoutLogs);

    if (recentFoodLogs.length < 3 || recentWorkoutLogs.length < 2) {
      return {
        insights: [
          "Keep logging your meals and workouts! We'll generate personalized insights once you have more data.",
          "Try to log at least 3 meals and 2 workouts to get meaningful nutrition insights.",
          "Focus on noting how you feel after eating and your energy levels during workouts."
        ],
        hasEnoughData: false
      };
    }

    const latestWorkout = recentWorkoutLogs.reduce((a,b)=>
    new Date(a.timestamp) > new Date(b.timestamp) ? a : b);

    const score = calculateTrainingLoad(latestWorkout);
    const plateType = latestWorkout.intensity; // assuming intensity field holds 'easy', 'moderate', or 'hard'
    const portionTargets = getPortionRangesFromPlate(plateType, score);

    const fuelGoalSummary = `
Fuel Goal Based on Last Workout (${plateType}):
- Carbs: ${portionTargets.carbs[0]}â€“${portionTargets.carbs[1]} portions
- Protein: ${portionTargets.protein[0]}â€“${portionTargets.protein[1]} portions
- Color: ${portionTargets.color[0]}â€“${portionTargets.color[1]} portions
`;

    const aiInsights = await callOpenAIForInsights(recentFoodLogs, recentWorkoutLogs, recentWellnessLogs, fuelGoalSummary);
    console.log("Raw OpenAI response:", aiInsights);

    if (!aiInsights || typeof aiInsights !== 'string') {
      throw new Error("OpenAI returned no usable insight string.");
    }

    const claudePrompt = `
You are a helpful assistant. Please review the following insights generated by an AI for a runner's nutrition and workout logs:

"""${aiInsights}"""

Your task:
- Simplify the language for clarity.
- Verify that the suggestions are safe and non-misleading.
- Remove any speculative or risky statements.
- Provide a concise, easy-to-understand summary of these insights.
- Do not renumber or rename the sections.


The output must preserve the format and section titles as given


`;

    const filteredInsights = await callClaudeForFilter(claudePrompt);
    console.log("Filtered Claude response:", filteredInsights);

    const finalInsights = typeof filteredInsights === 'string' && filteredInsights.trim().length > 0
      ? filteredInsights
      : aiInsights;

    if (!finalInsights || typeof finalInsights !== 'string') {
      throw new Error("No valid final insights string to parse.");
    }

    const parsed = parseInsights(finalInsights);

    return {
      insights: parsed,
      hasEnoughData: true,
      lastGenerated: new Date().toISOString()
    };

  } catch (error) {
    console.error('Error generating insights:', error);
    return {
      insights: [
        "Unable to generate insights right now. Please try again later.",
        "Make sure you're connected to the internet and have logged recent meals and workouts.",
        "Keep tracking your nutrition and training - insights will be available soon!"
      ],
      hasEnoughData: false
    };
  }
};

const callClaudeForFilter = async (promptText) => {
  const API_KEY = Constants.expoConfig.extra?.claudeApiKey;

  try {
    console.log("Using Claude API Key:", API_KEY ? "Yes" : "No");

    const response = await fetch("https://api.anthropic.com/v1/messages", {
      method: "POST",
      headers: {
        "x-api-key": API_KEY,
        "Content-Type": "application/json",
        "anthropic-version": "2023-06-01"
      },
      body: JSON.stringify({
        model: "claude-3-haiku-20240307",
        temperature: 0.7,
        max_tokens: 800,
        messages: [
          {
            role: "user",
            content: promptText
          }
        ]
      }),
    });

    const data = await response.json();
    console.log("Claude API response:", data);

    const reply = data?.content?.[0]?.text;
    if (!reply) {
      console.warn("Claude response did not include content:", data);
      return null;
    }

    return reply.trim();
  } catch (error) {
    console.error("Claude API error:", error);
    return null;
  }
};



const callOpenAIForInsights = async (foodLogs, workoutLogs, wellnessLogs, fuelGoalSummary) => {
  const API_KEY = Constants.expoConfig.extra?.openaiApiKey;

  const prompt = `
You are a sports nutrition expert analyzing a runner's logged meals and workouts over the past 7 days.

Generate a simplified, structured report with 3 clear sections:

### ðŸƒâ€â™‚ï¸ 1. Performance & Fuel Timing
- Show how specific meal timing/types impacted run pace or energy.

### ðŸ›Œ 2. Recovery & Wellness
- Connect food to post-run hunger, soreness, or next-day energy.

### ðŸ“ˆ 3. Trends & Suggestions
- Point out weekly patterns and give 2â€“3 simple suggestions to improve.

FUEL GOAL SUMMARY:
${fuelGoalSummary}

Keep each section short and easy to understand. Use bullet points or short phrases. Keep tone supportive and focused on what they can improve. When analyzing the logs, do not assume a meal was pre- or post-workout based on what was eaten. Use the timestamp and order of events to determine the meal context.

RECENT MEALS:
${foodLogs.map(meal => 
  `â€¢ ${formatTimestamp(meal.timestamp)}: ${meal.description || 'Meal logged'} 
    Tags: ${meal.tags ? meal.tags.join(', ') : 'None'}
    Feeling: ${meal.feeling || 'Not specified'}
    Type: ${meal.mealType || 'Not specified'}
     Portions: ðŸ¥¦ Color: ${meal.portions?.color || 0}, ðŸ— Protein: ${meal.portions?.protein || 0}, ðŸž Carbs: ${meal.portions?.carbs || 0}`
).join('\n')}

RECENT WORKOUTS:
${workoutLogs.map(workout => 
  `â€¢ ${formatTimestamp(workout.timestamp)}: ${workout.distance?.whole || 'N/A'}mi, ${workout.duration?.hours || 0}h ${workout.duration?.minutes || 0}m
    Type: ${workout.workoutType || 'Not specified'}
    Pace: ${workout.pace?.minutes || '-'}:${workout.pace?.seconds || '-'} per mi
    Notes: ${workout.journal || 'None'}`
).join('\n')}


WELLNESS ENTRIES:
${wellnessLogs.map(entry => 
  `â€¢ ${entry.date}
    Sleep: ${entry.sleepHours || 'N/A'}h (Quality: ${entry.sleepQuality || 'N/A'}/5)
    Hydration: ${entry.hydration || 'N/A'} oz
    Soreness: ${entry.soreness || 'N/A'}/10
    Mood: ${entry.mood || 'N/A'}
    Energy: ${entry.energyLevel || 'N/A'}
    Illness/Injury: ${entry.illnessInjury ? 'Yes' : 'No'}
    Menstrual Cycle: ${entry.menstrualCycle ? 'Yes' : 'No'}
    Notes: ${entry.notes || 'None'}`
).join('\n')}
`;

  const response = await fetch('https://api.openai.com/v1/chat/completions', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${API_KEY}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      model: "gpt-4o-mini",
      messages: [
        { role: "system", content: 'You are a sports nutrition expert giving short, clear, data-based insights for a runner.' },
        { role: "user", content: prompt }
      ],
      max_tokens: 300,
      temperature: 0.7
    })
  });

  const data = await response.json();
  console.log("OpenAI response object:", data);

console.log("OpenAI full response:", data);

  if (!data || !data.choices || !data.choices[0]?.message?.content) {
    throw new Error("OpenAI response missing expected structure.");
  }

  return data.choices[0].message.content;
};

const parseInsights = (aiResponse) => {
  try {
    if (!aiResponse || typeof aiResponse !== 'string') {
      console.warn("parseInsights received invalid input:", aiResponse);
      return [
        "Could not parse insights properly. Try logging more detailed data.",
        "Make sure your logs are consistent and recent for better insights.",
        "Come back later for refreshed nutrition insights."
      ];
    }

    // Split by ### + optional emoji + number + dot + space(s)
    const sections = aiResponse
      .split(/###\s*(?:\p{Emoji_Presentation}|\p{Emoji}\uFE0F)?\s*\d+\.\s+/u)
      .filter(section => section.trim().length > 0);

    const titles = [
      "ðŸ’¨ Performance & Fuel Timing",
      "ðŸ’ª Recovery & Wellness",
      "ðŸ“Š Trends & Suggestions"
    ];

    return sections.slice(0, 3).map((section, index) => {
      const lines = section.split('\n');

      // Remove any leading lines that are AI's own numbered titles
      while (lines.length > 0 && /^\s*(?:\p{Emoji_Presentation}|\p{Emoji}\uFE0F)?\s*\d+\.\s*.*$/u.test(lines[0])) {
        lines.shift();
      }

      let cleaned = lines.join('\n');

      cleaned = cleaned
        .replace(/[*_`~#>]/g, '')
        .replace(/\n{2,}/g, '\n')
        .trim();

      const title = titles[index] || `Section ${index + 1}`;

      return `${title}\n\n${cleaned}`;
    });
  } catch (error) {
    console.error("Error parsing insights:", error);
    return [
      "Could not parse insights properly. Try logging more detailed data.",
      "Make sure your logs are consistent and recent for better insights.",
      "Come back later for refreshed nutrition insights."
    ];
  }
};

const formatTimestamp = (timestamp) => {
  return new Date(timestamp).toLocaleDateString('en-US', {
    month: 'short',
    day: 'numeric',
    hour: 'numeric',
    minute: '2-digit'
  });
};

export const shouldRefreshInsights = (lastGenerated) => {
  if (!lastGenerated) return true;
  const threeDaysAgo = new Date();
  threeDaysAgo.setDate(threeDaysAgo.getDate() - 3);
  return new Date(lastGenerated) < threeDaysAgo;
};

export const saveInsightsToStorage = async (insights) => {
  try {
    await AsyncStorage.setItem('NUTRITION_INSIGHTS', JSON.stringify({
      insights: insights.insights,
      lastGenerated: insights.lastGenerated,
      hasEnoughData: insights.hasEnoughData
    }));
  } catch (error) {
    console.error('Error saving insights:', error);
  }
};

export const getSavedInsights = async () => {
  try {
    const saved = await AsyncStorage.getItem('NUTRITION_INSIGHTS');
    return saved ? JSON.parse(saved) : null;
  } catch (error) {
    console.error('Error getting saved insights:', error);
    return null;
  }
};



